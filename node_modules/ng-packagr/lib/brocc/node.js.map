{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/lib/brocc/node.ts"],"names":[],"mappings":";;AAAA,IAAI,UAAU,GAAG,CAAC,CAAC;AAIN,QAAA,WAAW,GAAc,OAAO,CAAC;AACjC,QAAA,gBAAgB,GAAc,aAAa,CAAC;AAC5C,QAAA,aAAa,GAAc,SAAS,CAAC;AACrC,QAAA,UAAU,GAAc,MAAM,CAAC;AAE5C;;GAEG;AACH;IACE,YAA4B,GAAW;QAAX,QAAG,GAAH,GAAG,CAAQ;QAMhC,UAAK,GAAc,EAAE,CAAC;QAkBrB,gBAAW,GAAW,EAAE,CAAC;QACzB,eAAU,GAAW,EAAE,CAAC;IAzBU,CAAC;IAQpC,MAAM,CAAC,EAA2C;QACvD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAED,IAAW,UAAU;QACnB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAKD,2IAA2I;IACpI,SAAS,CAAC,SAAwB;QACvC,MAAM,OAAO,GAAG,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAErE,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAEvG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW;aAChC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC;aACvE,MAAM,CAAC,OAAO,CAAC,CAAC;IACrB,CAAC;CACF;AAtCD,oBAsCC","sourcesContent":["let NODE_COUNT = 0;\n\nexport type NodeState = '' | 'dirty' | 'in-progress' | 'pending' | 'done';\n\nexport const STATE_DIRTY: NodeState = 'dirty';\nexport const STATE_IN_PROGESS: NodeState = 'in-progress';\nexport const STATE_PENDING: NodeState = 'pending';\nexport const STATE_DONE: NodeState = 'done';\n\n/**\n * A Node in the {@link BuildGraph}.\n */\nexport class Node {\n  constructor(public readonly url: string) {}\n\n  public type: string;\n\n  public data: any;\n\n  public state: NodeState = '';\n\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\n    return this._dependents.filter(by);\n  }\n\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\n    return this._dependents.find(by);\n  }\n\n  public some(by: (value: Node, index: number) => boolean): boolean {\n    return this._dependents.some(by);\n  }\n\n  public get dependents(): Node[] {\n    return this._dependents;\n  }\n\n  private _dependents: Node[] = [];\n  private _dependees: Node[] = [];\n\n  /** @experimental DO NOT USE. For time being, dirty checking is for `type=entryPoint && state !== 'done'` (full rebuild of entry point). */\n  public dependsOn(dependent: Node | Node[]) {\n    const newDeps = dependent instanceof Array ? dependent : [dependent];\n\n    newDeps.forEach(dep => (dep._dependees = dep._dependees.filter(d => d.url !== this.url).concat(this)));\n\n    this._dependents = this._dependents\n      .filter(existing => newDeps.some(newDep => newDep.url !== existing.url))\n      .concat(newDeps);\n  }\n}\n"]}